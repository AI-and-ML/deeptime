<script type="text/javascript">

const width = 600;
const height = 400;
const linkDistance = 300;
const nodeRadius = 8;
const nodeRadiusExpanded = 16;

const data = {

    nodes: [
        {id: 0, name: "TICA", full_name: "time-lagged independent component analysis", group: 0, url: "notebooks/tica.html"},
        {id: 1, name: "VAC", full_name: "variational approach of conformational dynamics", group: 0, url: "notebooks/vamp.html"},
        {id: 2, name: "VAMP / TCCA", full_name: "variational approach for Markov processes / time-lagged canonical correlation analysis", group: 0, url: "notebooks/vamp.html"},
        {id: 3, name: "kVAMP / kCCA", full_name: "kernel VAMP / kernel canonical correlation analysis", group: 0, url: "notebooks/kcca.html"},
        {id: 4, name: "MSM", full_name: "Markov state model", group: 1, url: "index_msm.html"},
        {id: 5, name: "DMD", full_name: "dynamic mode decomposition", group: 2, url: "notebooks/dmd.html"},
        {id: 6, name: "EDMD", full_name: "extended dynamic mode decomposition", group: 2, url: "notebooks/edmd.html"},
        {id: 7, name: "kEDMD", full_name: "kernel extended dynamic mode decomposition", group: 2, url: "notebooks/kedmd.html"},
        // {id: 8, name: "KVAD", full_name: "kernel embedding-based variational approach for dynamical systems", group: 0},
    ],
    edges: [
        {source: 1, target: 0, value: 1},  // VAC -> TICA
        {source: 1, target: 2, value: 1},  // VAC -> VAMP
        {source: 2, target: 3, value: 1},  // VAMP -> kCCA
        {source: 1, target: 4, value: 1},  // VAC -> MSM
        {source: 2, target: 4, value: 1},  // VAMP -> MSM
        {source: 6, target: 4, value: 1},  // EDMD -> MSM
        // {source: 2, target: 8, value: 1},  // VAMP -> KVAD
        {source: 0, target: 5, value: 2},  // TICA <-> DMD
        {source: 1, target: 6, value: 2},  // VAC <-> EDMD
        {source: 6, target: 5, value: 1},  // EDMD -> DMD
        {source: 6, target: 7, value: 1},  // EDMD -> kEDMD
    ]
};

const scale = d3.scaleOrdinal(d3.schemeCategory10);

const links = data.edges.map(d => Object.create(d));
const nodes = data.nodes.map(d => Object.create(d));

// Define the div for the tooltip
const div = d3.select("body").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);

const svg = d3.select("div#koopman_algos_container")
   .append("div")
   // Container class to make it responsive.
   .classed("svg-container", true)
   .append("svg")
   // Responsive SVG needs these 2 attributes and no width and height attr.
   .attr("preserveAspectRatio", "xMinYMin meet")
   .attr("viewBox", "0 0 600 400")
   // Class to make it responsive.
   .classed("svg-content-responsive", true)

svg.append("svg:defs").selectAll("marker")
    .data(["end"])      // Different link/path types can be defined here
  .enter().append("svg:marker")    // This section adds in the arrows
    .attr("id", String)
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", 15)
    .attr("refY", 0.5)
    .attr("markerWidth", 2)
    .attr("markerHeight", 2)
    .attr("orient", "auto")
  .append("svg:path")
    .attr("d", "M0,-5L10,0L0,5");

const simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).id(d => d.id))
    .force("charge", d3.forceManyBody().strength(-500).distanceMax(400))
    .force("center", d3.forceCenter(width / 2, height / 2));

// const svg = d3.select("#viz").attr("width", width).attr("height", height);

var x = d3.scaleBand()
    .rangeRound([0, width])
    .padding(0.1);

function getTargetNodeCircumferencePoint(d){
        var t_radius = nodeRadius; // nodeWidth is just a custom attribute I calculate during the creation of the nodes depending on the node width
        var dx = d.target.x - d.source.x;
        var dy = d.target.y - d.source.y;
        var gamma = Math.atan2(dy,dx); // Math.atan2 returns the angle in the correct quadrant as opposed to Math.atan
        var tx = d.target.x - (Math.cos(gamma) * t_radius);
        var ty = d.target.y - (Math.sin(gamma) * t_radius);

        return [tx,ty];
}

const link = svg.append("g")
    .attr("stroke", "#999")
    .attr("stroke-opacity", 0.6)
    .selectAll("line")
    .data(links)
    .join("line")
    .attr("stroke-width", 1.5)
    .attr('marker-begin','url(#end)')
    .attr('marker-end','url(#end)');

var node = svg.selectAll("g.node")
    .data(nodes)
    .enter()
    .append("svg:g")
    .attr("class", "clickable")
    .attr("cursor", "pointer")
    .on("click", function(d) { window.open(d.url) });

var circles = node.append("circle")
    .attr("r", nodeRadius)
    .attr("fill", d => scale(d.group));

var labels = node.append("text")
    .text(d => d.name)
    .merge(node)
    .attr('x', 10)
    .attr('y', 7)
    .style("font-size", "11px")
    .style("fill", "Black");

circles.call(
    d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended)
);

simulation.on("tick", () => {
    link.attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", function(d) {
             return getTargetNodeCircumferencePoint(d)[0];
        })
        .attr("y2", function(d) {
             return getTargetNodeCircumferencePoint(d)[1];
        });
        //.attr("x2", d => d.target.x)
        //.attr("y2", d => d.target.y);
    circles.attr("cx", d => d.x)
           .attr("cy", d => d.y);

    labels.attr("transform", function (d) { return "translate(" + d.x + "," + d.y + ")"; });
});

function dragstarted(d) {
    d3.event.sourceEvent.stopPropagation();
    if (!d3.event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
}

function dragged(d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
}

function dragended(d) {
    if (!d3.event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
}

node.on("mouseover", function(d) {

        /*d3.select(this).select('text')
          .transition()
          .duration(300)
          .text(function(d) {
            return d.full_name;
          })
          .style("font-size", "15px");
        */

        d3.select(this).select('circle')
          .transition()
          .duration(300)
          .attr("r", nodeRadiusExpanded)

        div.transition()
            .duration(200)
            .style("opacity", .9);
        div.html(d.full_name).style("left", (d3.event.pageX) + "px").style("top", (d3.event.pageY - 28) + "px");
});

node.on("mouseout", function(d) {
    div.transition().duration(500).style("opacity", 0);
    /*d3.select(this).select('text')
        .transition()
        .duration(300)
        .text(function(d) {
            return d.name;
        })
        .style("font-size", "11px");*/
    d3.select(this).select('circle')
        .transition()
        .duration(300)
        .attr("r", nodeRadius);
});
</script>
