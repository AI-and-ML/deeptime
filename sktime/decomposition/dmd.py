from typing import Tuple

import numpy as np

from ..base import Estimator, Model, Transformer
from ..kernels import Kernel
from ..numeric import sort_by_norm


class DMDModel(Model, Transformer):
    r""" Model produced by the :class:`DMD` estimator.
    """

    def __init__(self, eigenvalues: np.ndarray, modes: np.ndarray, mode='exact'):
        r""" Creates a new model instance.

        Parameters
        ----------
        eigenvalues : (n,) ndarray
            The DMD eigenvalues.
        modes : (n, n) ndarray
            The DMD modes.
        mode : str, optional, default='exact'
            The mode of estimation that was used. See :attr:`DMD.available_modes`.
        """
        super().__init__()
        self.eigenvalues = eigenvalues
        self.modes = modes
        self.mode = mode

    def transform(self, data, **kwargs):
        if self.mode == 'exact':
            modes_adj = np.linalg.pinv(self.modes)
            return np.linalg.multi_dot([
                self.modes, np.diag(self.eigenvalues), modes_adj, data.T
            ]).T
        else:
            return np.linalg.multi_dot([
                self.modes, np.diag(self.eigenvalues), self.modes.conj().T, data.T
            ]).T


class DMD(Estimator, Transformer):
    r""" Dynamic mode decomposition :cite:`dmd-schmid2010dynamic` estimator.

    There are two supported modes:

    * `standard`, which produces "projected" DMD modes (following the original formulation of DMD),
    * `exact`, which produces DMD modes that do not required ordered data but just
      matched pairs of data :cite:`dmd-tu2013dynamic`.

    Notes
    -----
    In standard DMD, one considers a temporally ordered list of
    data vectors :math:`(z_0,\ldots,z_T)\in\mathbb{R}^{T\times d}`. The data is split into the pair

    .. math::

        X = (z_0, \ldots, z_{T-1}),\quad Y=(z_1,\ldots, z_T).

    If the mode is `exact`, the list does not need to be temporally ordered but just the pairs :math:`(X_i, Y_i)`
    have to match. The underlying assumption is that the data are generated by a linear relationship

    .. math::

        z_{t+1} = A z_t

    for some matrix :math:`A`.

    The so-called DMD modes and eigenvalues are then the (potentially scaled) eigenvectors and eigenvalues of :math:`A`.

    References
    ----------
    .. bibliography:: /references.bib
        :style: unsrt
        :filter: docname in docnames
        :keyprefix: dmd-
    """

    available_modes = 'exact', 'standard'  #: The available estimation modes.

    def __init__(self, mode='exact'):
        r"""Creates a new DMD estimator.

        Parameters
        ----------
        mode : str
            The estimation mode, see :attr:`available_modes` for available modes.
        """
        super().__init__()
        if mode not in DMD.available_modes:
            raise ValueError(f"Invalid mode {mode}, must be one of {DMD.available_modes}.")
        self.mode = mode

    def fit(self, data: Tuple[np.ndarray, np.ndarray], **kwargs):
        X, Y = data[0].T, data[1].T  # per convention arrays are [T, d] so here we transpose them

        U, s, Vt = np.linalg.svd(X, full_matrices=False)
        V = Vt.conj().T
        S_inv = np.diag(1 / s)
        A = np.linalg.multi_dot([U.conj().T, Y, V, S_inv])

        eigenvalues, eigenvectors = np.linalg.eig(A)
        eigenvalues, eigenvectors = sort_by_norm(eigenvalues, eigenvectors)

        if self.mode == 'exact':
            dmd_modes = np.linalg.multi_dot([Y, V, S_inv, eigenvectors, np.diag(1 / eigenvalues)])
        elif self.mode == 'standard':
            dmd_modes = U @ eigenvectors
        else:
            raise ValueError('Only exact and standard DMD available.')

        self._model = DMDModel(eigenvalues, dmd_modes)

        return self

    def fetch_model(self):
        r""" Yields the estimated model if :meth:`fit` was called.

        Returns
        -------
        model : DMDModel or None
            The model or None.
        """
        return self._model

    def transform(self, data, **kwargs):
        r""" Predicts the propagated data given input.

        Parameters
        ----------
        data : (T, d) np.ndarray
            Input data

        Returns
        -------
        result : (T, d) np.ndarray
            Propagated input data
        """
        return self.fetch_model().transform(data, **kwargs)


class KernelEDMDModel(Model):
    def __init__(self, P, K):
        super().__init__()
        self.P = P
        self.K = K


class KernelEDMDEstimator(Estimator):

    def __init__(self, kernel: Kernel, epsilon: float = 0., n_eig: int = 5):
        super().__init__()
        self.kernel = kernel
        self.epsilon = epsilon
        self.n_eig = n_eig

    def fit(self, data: Tuple[np.ndarray, np.ndarray], **kwargs):
        gram_0 = self.kernel.gram(data[0])
        gram_1 = self.kernel.apply(*data)

        if self.epsilon > 0:
            reg = self.epsilon * np.eye(gram_0.shape[0])
        else:
            reg = 0
        A = np.linalg.pinv(gram_0 + reg, rcond=1e-15) @ gram_1
        eigenvalues, eigenvectors = np.linalg.eig(A)
        eigenvalues, eigenvectors = sort_by_norm(eigenvalues, eigenvectors)
        perron_frobenius_operator = eigenvectors
        koopman_operator = gram_0 @ eigenvectors

        self._model = KernelEDMDModel(perron_frobenius_operator, koopman_operator)

        return self
